<h1>Introduction</h1><h2>Executable Documentation</h2><p>Everything in this documentation is executed as part of the build process, so all the examples are guaranteed to run with the latest master branch of Dollar. </p><p>Yep Dollar can actually run Markdown files, in fact the source file that this page was built from starts with:</p>
<pre><code>#!/usr/bin/env dollar
</code></pre><p>So it can be executed directly from a Unix command line.</p><p>The source for this page (minus that header) is <a href="scripting.md">here</a></p><h2>Getting Started</h2><p>NOTE: At present only Mac OS X is officially supported, however since Dollar is entirely based in Java it's trivial to port to other systems.</p><p>First download the Dollar scripting runtime from <a href="https://bintray.com/neilellis/dollar/dollar-runtime-osx/_latestVersion"> <img src="https://api.bintray.com/packages/neilellis/dollar/dollar-runtime-osx/images/download.svg" alt="Download""/> </a> </p><p>Make sure <code>dollar/bin</code> is on your PATH.</p><p>Run <code>dollar &lt;filename&gt;</code> to execute a Dollar script. </p><p>Here is an example of what DollarScript looks like</p>
<pre><code class="dollar  "><br/>testParams := ($2 + &quot; &quot; + $1)

=&gt; $testParams (&quot;Hello&quot;, &quot;World&quot;) == &quot;World Hello&quot;

</code></pre><h1>Understanding the Basics</h1><p>DollarScript has it's own peculiarities, mostly these exists to help with it's major function - data/API centric Internet applications. So it's important to understand the basic concepts before getting started.</p><h2>Reactive Programming</h2><p>DollarScript expressions are by default <em>lazy</em>, this is really important to understand otherwise you may get some surprises. This lazy evaluation makes DollarScript a <a href="http://en.wikipedia.org/wiki/Reactive_programming">reactive programming language</a> by default.</p><p>Let's see some of that behaviour in action:</p>
<pre><code class="dollar"><br/>variableA := 1
variableB := $variableA
variableA := 2

=&gt; $variableB == 2 
</code></pre><p>In the above example we are declaring (using the declarative operator <code>:=</code>) that variableA is current the value 1, we then declare that variableB is the <em>same as</em> variableA. So when we change variableA to 2 we also change variableB to 2.</p><p>The assertion operator <code>=&gt;</code> will throw an assertion error if the value following is either non boolean or not true.</p><p>Now let's throw in the -&gt; or causes operator :</p>
<pre><code class="dollar"><br/>a=1
$a -&gt; { &gt;&gt; $a }
a=2
a=3
a=4
 
</code></pre>
<pre><code>2
3
4
</code></pre><p>That remarkable piece of code will simply output each change made to the variable a, but wait a minute what about ...</p>
<pre><code class="dollar"><br/>b=1
a=1
$a + $b + 1 -&gt; { &gt;&gt; &quot;a=&quot; + $a + &quot;, b=&quot; + $b}
a=2
a=3
a=4
b=2 
</code></pre>
<pre><code>a=2, b=1 
a=3, b=1 
a=4, b=1 
a=4, b=2 
</code></pre><p>Yep, you can write reactive expressions based on collections or arbitrary expressions !! When any component changes the right hand side is re-evaluated (the actual value that changed is passed in as $1).</p><h3>Assignment</h3><p>Obviously the declarative/reactive behavior is fantastic for templating and creating lambda style expressions, however a lot of the time we want to simply assign a value.</p>
<pre><code class="dollar"><br/>variableA = 1
variableB = $variableA
variableA = 2

=&gt; $variableB == 1 
</code></pre><p>So as you can see when we use the <code>=</code> assignment operator we assign the <em>value</em> of the right hand side to the variable. Watch what happens when we use expressions.</p>
<pre><code class="dollar"><br/>variableA = 1
variableB = $variableA
variableC = ($variableA +1 )
variableD := ($variableA + 1)
variableA = 2

=&gt; $variableB == 1 
=&gt; $variableC == 2 
=&gt; $variableD == 3
 
</code></pre><p>So <code>:=</code> allows the default behaviour of Dollar, which is to make everything declarative, and <code>=</code> is used to nail down a particular value. Later we'll come across the value anchor operator or diamond <code>&lt;&gt;</code> which instructs DollarScript to fix a value at the time of declaration. More on that later.</p><h3>Blocks</h3><p>DollarScript supports several block types, the first is the 'line block' a line block lies between <code>{</code> and <code>}</code> and is separated by either newlines or <code>;</code> characters.</p>
<pre><code class="dollar"><br/>block := {
    &quot;Hello &quot;
    &quot;World&quot;
}

=&gt; $block == &quot;World&quot;

block2 := {1;2;}

=&gt; $block2 == 2

</code></pre><p>When a line block is evaluated the result is the value of the last entry. For advanced users note that all lines will be evaluated, the value is just ignored. A line block behaves a lot like a function in an imperative language.</p><p>Next we have the array block, the array block preserves all the values each part is seperated by either a <code>,</code> or a newline but is delimited by <code>[</code> and <code>]</code>.</p>
<pre><code class="dollar"><br/>array := [
    &quot;Hello &quot;
    &quot;World&quot;
]

=&gt; $array == [&quot;Hello &quot;,&quot;World&quot;]

array2 := [1,2]

=&gt; $array2 == [1,2]

</code></pre><p>Finally we have the appending block, when an appending (or map) block is evaluated the result is the concatenation (using $plus() in the Dollar API) of the parts from top to bottom. The appending block starts and finishes with the <code>{</code> <code>}</code> braces, however each part is seperated by a <code>,</code> not a <code>;</code> or <em>newline</em></p>
<pre><code class="dollar"><br/>appending := {
    &quot;Hello &quot;,
    &quot;World&quot;
}

=&gt; $appending == &quot;Hello World&quot;

appending2 := { 1, 2}

=&gt; $appending2 == 3

</code></pre><p>Appending blocks can be combined with the pair <code>:</code> operator to create maps/JSON like this:</p>
<pre><code class="dollar"><br/>appending := {
    first:&quot;Hello &quot;,
    second:&quot;World&quot;
}

&gt;&gt; $appending

=&gt; $appending.second == &quot;World&quot;

</code></pre><p>The stdout operator <code>&gt;&gt;</code> is used to send a value to stdout in it's serialized (JSON) format, so the result of the above would be to output <code>{&quot;first&quot;:&quot;Hello &quot;,&quot;second&quot;:&quot;World&quot;}</code> a JSON object created using JSON like syntax. This works because of how appending works with pairs, i.e. they are joined together to form a map.</p>
<pre><code class="dollar"><br/>pair1 := first : &quot;Hello &quot;;
pair2 := second : &quot;World&quot;;
  
=&gt; $pair1 + $pair2 == {&quot;first&quot;:&quot;Hello &quot;,&quot;second&quot;:&quot;World&quot;}
 
</code></pre><h3>Reactive Control Flow</h3><p>DollarScript as previously mentioned is a reactive programming language, that means that changes to one part of your program can automatically affect another. Consider this a 'push' model instead of the usual 'pull' model.</p><p>Let's start with the simplest reactive control flow operator, the '-&gt;' or 'causes' operator. </p>
<pre><code class="dollar"><br/>$a -&gt; { &gt;&gt; $a } //alternatively for clarity &#39;$a causes {&gt;&gt; $a} &#39;

a=1
a=2
a=3
a=4
a=2
 
</code></pre><p>When the code is executed we'll see the values 1,2,3,4,2 printed out, this is because whenever <code>$a</code> changes the block { &gt;&gt; $a } is evaluated, resulting in the variable $a being printed to stdout. Imagine how useful that is for debugging changes to a variable!</p><p>Next we have the 'when' operator, there is no shorthand for this operator, to help keep you code readable:</p>
<pre><code class="dollar"><br/>a=1
 
when $a == 2 { &gt;&gt; $a } 

a=2
a=3
a=4
a=2
 
</code></pre><p>This time we'll just see the number 2 twice, this is because the <code>when</code> operator triggers the evaluation of the supplied block ONLY when the supplied expression (<code>$a == 2</code>) becomes true. </p><h3>Reactive Operators</h3><h4>Split, Filter and Aggregate</h4>
<!--
split - % <filter expression>

Converts a list into a stream of values matching the filter

```
b := $a % (true)
b := $a % ($1 > 3)
```

filter - ^ <filter expression>

```
b := $a ^ ($1 > 100)
```

b will not generate events if a's value is <= 100, also b will be void if queried during that state.

aggregate - & <emit condition>

Aggregate until emit condition is true and then emit the result

$1 == aggregate
$2 == previous value
$3 == current value
$4 == next value

```
    b :=  $a & ($2 == ';')
```
--><h2>Imperative Control Flow</h2><h2>Parameters &amp; Functions</h2><h2>Resources &amp; URIs</h2><p>URIs are first class citizen's in DollarScript. They refer to a an arbitrary resource, usually remote, that can be accessed using the specified protocol and location. Static URIs can be referred to directly without quotation marks, dynamic URIs can be built using the <code>uri</code> operator</p>
<pre><code class="dollar"><br/><br/>search=&quot;Unikitty&quot;
dynamicURI= uri &quot;http://google.com?q=&quot;+$search

marinaVideos = &lt;+ https://itunes.apple.com/search?term=Marina+And+The+Diamonds&amp;entity=musicVideo
&gt;&gt; each $marinaVideos.results { $1.trackViewUrl }

</code></pre><p>In this example we've requested a single value (using <code>&lt;+</code>) from a uri and assigned the value to <code>$marinaVideos</code> then we simply iterate over the results using <code>each</code> and each value (passed in to the scope as <code>$1</code>) we extract the <code>trackViewUrl</code>. The each operator returns a list of the results and that is what is passed to standard out.</p><h2>Iterative Operators</h2><h2>Numerical Operators</h2><h2>Arrays</h2><p>DollarScript's arrays are pretty similar to JavaScript. They are defined using the <code>[1,2,3]</code> style syntax and accessed using the <code>x[y]</code> subscript syntax.</p>
<pre><code class="dollar">=&gt; [1,2,3] + 4 == [1,2,3,4];
=&gt; [1,2,3,4] - 4 == [1,2,3];
=&gt; [] + 1 == [1] ;
=&gt; [1] + [1] == [1,[1]];
=&gt; [1] + 1 == [1,1];

[1,2,3][1] &lt;=&gt; 2
</code></pre><p><em>Note we're introducing the assert equals or <code>&lt;=&gt;</code> operator here, this is a combination of <code>=&gt;</code> and <code>==</code> that will cause an error if the two values are not equal.</em></p><p>DollarScript maps are also associative arrays (like JavaScript) allowing you to request members from them using the array subscript syntax</p>
<pre><code class="dollar">{&quot;key1&quot;:1,&quot;key2&quot;:2} [&quot;key&quot;+1] &lt;=&gt; 1
{&quot;key1&quot;:1,&quot;key2&quot;:2} [1] &lt;=&gt; {&quot;key2&quot;:2}
{&quot;key1&quot;:1,&quot;key2&quot;:2} [1][&quot;key2&quot;] &lt;=&gt; 2
</code></pre><p>As you can see from the example you can request a key/value pair (or Tuple if you like) by it's position using a numeric subscript. Or you can treat it as an associative array and request an entry by specifying the key name. Any expression can be used as a subscript, numerical values will be used as indexes, otherwise the string value will be used as a key.</p><h2>Pipe Operators</h2><h2>Modules &amp; Module Locators</h2><h2>Remaining Operators</h2><h2>Concurrency &amp; Threads</h2>